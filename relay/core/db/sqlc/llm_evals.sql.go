// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: llm_evals.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEvalStats = `-- name: GetEvalStats :one
SELECT
    stage,
    COUNT(*) as total,
    COUNT(rating) as rated,
    AVG(rating)::float as avg_rating,
    AVG(eval_score)::float as avg_eval_score,
    AVG(latency_ms)::int as avg_latency_ms
FROM llm_evals
WHERE stage = $1
  AND created_at > $2
GROUP BY stage
`

type GetEvalStatsParams struct {
	Stage     string             `json:"stage"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type GetEvalStatsRow struct {
	Stage        string  `json:"stage"`
	Total        int64   `json:"total"`
	Rated        int64   `json:"rated"`
	AvgRating    float64 `json:"avg_rating"`
	AvgEvalScore float64 `json:"avg_eval_score"`
	AvgLatencyMs int32   `json:"avg_latency_ms"`
}

func (q *Queries) GetEvalStats(ctx context.Context, arg GetEvalStatsParams) (GetEvalStatsRow, error) {
	row := q.db.QueryRow(ctx, getEvalStats, arg.Stage, arg.CreatedAt)
	var i GetEvalStatsRow
	err := row.Scan(
		&i.Stage,
		&i.Total,
		&i.Rated,
		&i.AvgRating,
		&i.AvgEvalScore,
		&i.AvgLatencyMs,
	)
	return i, err
}

const getLLMEvalByID = `-- name: GetLLMEvalByID :one
SELECT id, workspace_id, issue_id, stage, input_text, output_json, model, temperature, prompt_version, latency_ms, prompt_tokens, completion_tokens, rating, rating_notes, rated_by_user_id, rated_at, expected_json, eval_score, created_at FROM llm_evals WHERE id = $1
`

func (q *Queries) GetLLMEvalByID(ctx context.Context, id int64) (LlmEval, error) {
	row := q.db.QueryRow(ctx, getLLMEvalByID, id)
	var i LlmEval
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.IssueID,
		&i.Stage,
		&i.InputText,
		&i.OutputJson,
		&i.Model,
		&i.Temperature,
		&i.PromptVersion,
		&i.LatencyMs,
		&i.PromptTokens,
		&i.CompletionTokens,
		&i.Rating,
		&i.RatingNotes,
		&i.RatedByUserID,
		&i.RatedAt,
		&i.ExpectedJson,
		&i.EvalScore,
		&i.CreatedAt,
	)
	return i, err
}

const insertLLMEval = `-- name: InsertLLMEval :one
INSERT INTO llm_evals (
    id, workspace_id, issue_id, stage,
    input_text, output_json,
    model, temperature, prompt_version,
    latency_ms, prompt_tokens, completion_tokens,
    created_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6,
    $7, $8, $9,
    $10, $11, $12,
    NOW()
) RETURNING id, workspace_id, issue_id, stage, input_text, output_json, model, temperature, prompt_version, latency_ms, prompt_tokens, completion_tokens, rating, rating_notes, rated_by_user_id, rated_at, expected_json, eval_score, created_at
`

type InsertLLMEvalParams struct {
	ID               int64    `json:"id"`
	WorkspaceID      *int64   `json:"workspace_id"`
	IssueID          *int64   `json:"issue_id"`
	Stage            string   `json:"stage"`
	InputText        string   `json:"input_text"`
	OutputJson       []byte   `json:"output_json"`
	Model            string   `json:"model"`
	Temperature      *float64 `json:"temperature"`
	PromptVersion    *string  `json:"prompt_version"`
	LatencyMs        *int32   `json:"latency_ms"`
	PromptTokens     *int32   `json:"prompt_tokens"`
	CompletionTokens *int32   `json:"completion_tokens"`
}

func (q *Queries) InsertLLMEval(ctx context.Context, arg InsertLLMEvalParams) (LlmEval, error) {
	row := q.db.QueryRow(ctx, insertLLMEval,
		arg.ID,
		arg.WorkspaceID,
		arg.IssueID,
		arg.Stage,
		arg.InputText,
		arg.OutputJson,
		arg.Model,
		arg.Temperature,
		arg.PromptVersion,
		arg.LatencyMs,
		arg.PromptTokens,
		arg.CompletionTokens,
	)
	var i LlmEval
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.IssueID,
		&i.Stage,
		&i.InputText,
		&i.OutputJson,
		&i.Model,
		&i.Temperature,
		&i.PromptVersion,
		&i.LatencyMs,
		&i.PromptTokens,
		&i.CompletionTokens,
		&i.Rating,
		&i.RatingNotes,
		&i.RatedByUserID,
		&i.RatedAt,
		&i.ExpectedJson,
		&i.EvalScore,
		&i.CreatedAt,
	)
	return i, err
}

const listLLMEvalsByIssue = `-- name: ListLLMEvalsByIssue :many
SELECT id, workspace_id, issue_id, stage, input_text, output_json, model, temperature, prompt_version, latency_ms, prompt_tokens, completion_tokens, rating, rating_notes, rated_by_user_id, rated_at, expected_json, eval_score, created_at FROM llm_evals
WHERE issue_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListLLMEvalsByIssue(ctx context.Context, issueID *int64) ([]LlmEval, error) {
	rows, err := q.db.Query(ctx, listLLMEvalsByIssue, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmEval
	for rows.Next() {
		var i LlmEval
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Stage,
			&i.InputText,
			&i.OutputJson,
			&i.Model,
			&i.Temperature,
			&i.PromptVersion,
			&i.LatencyMs,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.Rating,
			&i.RatingNotes,
			&i.RatedByUserID,
			&i.RatedAt,
			&i.ExpectedJson,
			&i.EvalScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLLMEvalsByStage = `-- name: ListLLMEvalsByStage :many
SELECT id, workspace_id, issue_id, stage, input_text, output_json, model, temperature, prompt_version, latency_ms, prompt_tokens, completion_tokens, rating, rating_notes, rated_by_user_id, rated_at, expected_json, eval_score, created_at FROM llm_evals
WHERE stage = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListLLMEvalsByStageParams struct {
	Stage string `json:"stage"`
	Limit int32  `json:"limit"`
}

func (q *Queries) ListLLMEvalsByStage(ctx context.Context, arg ListLLMEvalsByStageParams) ([]LlmEval, error) {
	rows, err := q.db.Query(ctx, listLLMEvalsByStage, arg.Stage, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmEval
	for rows.Next() {
		var i LlmEval
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Stage,
			&i.InputText,
			&i.OutputJson,
			&i.Model,
			&i.Temperature,
			&i.PromptVersion,
			&i.LatencyMs,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.Rating,
			&i.RatingNotes,
			&i.RatedByUserID,
			&i.RatedAt,
			&i.ExpectedJson,
			&i.EvalScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnratedLLMEvals = `-- name: ListUnratedLLMEvals :many
SELECT id, workspace_id, issue_id, stage, input_text, output_json, model, temperature, prompt_version, latency_ms, prompt_tokens, completion_tokens, rating, rating_notes, rated_by_user_id, rated_at, expected_json, eval_score, created_at FROM llm_evals
WHERE rating IS NULL
  AND stage = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListUnratedLLMEvalsParams struct {
	Stage string `json:"stage"`
	Limit int32  `json:"limit"`
}

func (q *Queries) ListUnratedLLMEvals(ctx context.Context, arg ListUnratedLLMEvalsParams) ([]LlmEval, error) {
	rows, err := q.db.Query(ctx, listUnratedLLMEvals, arg.Stage, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmEval
	for rows.Next() {
		var i LlmEval
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Stage,
			&i.InputText,
			&i.OutputJson,
			&i.Model,
			&i.Temperature,
			&i.PromptVersion,
			&i.LatencyMs,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.Rating,
			&i.RatingNotes,
			&i.RatedByUserID,
			&i.RatedAt,
			&i.ExpectedJson,
			&i.EvalScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rateLLMEval = `-- name: RateLLMEval :exec
UPDATE llm_evals
SET rating = $2,
    rating_notes = $3,
    rated_by_user_id = $4,
    rated_at = NOW()
WHERE id = $1
`

type RateLLMEvalParams struct {
	ID            int64   `json:"id"`
	Rating        *int32  `json:"rating"`
	RatingNotes   *string `json:"rating_notes"`
	RatedByUserID *int64  `json:"rated_by_user_id"`
}

func (q *Queries) RateLLMEval(ctx context.Context, arg RateLLMEvalParams) error {
	_, err := q.db.Exec(ctx, rateLLMEval,
		arg.ID,
		arg.Rating,
		arg.RatingNotes,
		arg.RatedByUserID,
	)
	return err
}

const setLLMEvalExpected = `-- name: SetLLMEvalExpected :exec
UPDATE llm_evals
SET expected_json = $2,
    eval_score = $3
WHERE id = $1
`

type SetLLMEvalExpectedParams struct {
	ID           int64    `json:"id"`
	ExpectedJson []byte   `json:"expected_json"`
	EvalScore    *float64 `json:"eval_score"`
}

func (q *Queries) SetLLMEvalExpected(ctx context.Context, arg SetLLMEvalExpectedParams) error {
	_, err := q.db.Exec(ctx, setLLMEvalExpected, arg.ID, arg.ExpectedJson, arg.EvalScore)
	return err
}
