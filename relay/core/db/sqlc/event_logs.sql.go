// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event_logs.sql

package sqlc

import (
	"context"
)

const createEventLog = `-- name: CreateEventLog :one
INSERT INTO event_logs (
    id, workspace_id, issue_id, source, event_type,
    payload, external_id, dedupe_key, created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now())
RETURNING id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at
`

type CreateEventLogParams struct {
	ID          int64   `json:"id"`
	WorkspaceID int64   `json:"workspace_id"`
	IssueID     int64   `json:"issue_id"`
	Source      string  `json:"source"`
	EventType   string  `json:"event_type"`
	Payload     []byte  `json:"payload"`
	ExternalID  *string `json:"external_id"`
	DedupeKey   string  `json:"dedupe_key"`
}

func (q *Queries) CreateEventLog(ctx context.Context, arg CreateEventLogParams) (EventLog, error) {
	row := q.db.QueryRow(ctx, createEventLog,
		arg.ID,
		arg.WorkspaceID,
		arg.IssueID,
		arg.Source,
		arg.EventType,
		arg.Payload,
		arg.ExternalID,
		arg.DedupeKey,
	)
	var i EventLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.IssueID,
		&i.Source,
		&i.EventType,
		&i.Payload,
		&i.ExternalID,
		&i.DedupeKey,
		&i.ProcessedAt,
		&i.ProcessingError,
		&i.CreatedAt,
	)
	return i, err
}

const getEventLog = `-- name: GetEventLog :one
SELECT id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at FROM event_logs WHERE id = $1
`

func (q *Queries) GetEventLog(ctx context.Context, id int64) (EventLog, error) {
	row := q.db.QueryRow(ctx, getEventLog, id)
	var i EventLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.IssueID,
		&i.Source,
		&i.EventType,
		&i.Payload,
		&i.ExternalID,
		&i.DedupeKey,
		&i.ProcessedAt,
		&i.ProcessingError,
		&i.CreatedAt,
	)
	return i, err
}

const listEventLogsByWorkspace = `-- name: ListEventLogsByWorkspace :many
SELECT id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at FROM event_logs
WHERE workspace_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListEventLogsByWorkspaceParams struct {
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
}

func (q *Queries) ListEventLogsByWorkspace(ctx context.Context, arg ListEventLogsByWorkspaceParams) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listEventLogsByWorkspace, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Source,
			&i.EventType,
			&i.Payload,
			&i.ExternalID,
			&i.DedupeKey,
			&i.ProcessedAt,
			&i.ProcessingError,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventLogsByWorkspaceAndSource = `-- name: ListEventLogsByWorkspaceAndSource :many
SELECT id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at FROM event_logs
WHERE workspace_id = $1 AND source = $2
ORDER BY created_at DESC
LIMIT $3
`

type ListEventLogsByWorkspaceAndSourceParams struct {
	WorkspaceID int64  `json:"workspace_id"`
	Source      string `json:"source"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) ListEventLogsByWorkspaceAndSource(ctx context.Context, arg ListEventLogsByWorkspaceAndSourceParams) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listEventLogsByWorkspaceAndSource, arg.WorkspaceID, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Source,
			&i.EventType,
			&i.Payload,
			&i.ExternalID,
			&i.DedupeKey,
			&i.ProcessedAt,
			&i.ProcessingError,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedEventLogs = `-- name: ListUnprocessedEventLogs :many
SELECT id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at FROM event_logs
WHERE processed_at IS NULL
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) ListUnprocessedEventLogs(ctx context.Context, limit int32) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listUnprocessedEventLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Source,
			&i.EventType,
			&i.Payload,
			&i.ExternalID,
			&i.DedupeKey,
			&i.ProcessedAt,
			&i.ProcessingError,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedEventLogsByIssue = `-- name: ListUnprocessedEventLogsByIssue :many
SELECT id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at FROM event_logs
WHERE issue_id = $1
  AND processed_at IS NULL
ORDER BY created_at ASC
`

// Get all unprocessed events for an issue, ordered by creation time.
// Used by worker to batch-process all pending events.
func (q *Queries) ListUnprocessedEventLogsByIssue(ctx context.Context, issueID int64) ([]EventLog, error) {
	rows, err := q.db.Query(ctx, listUnprocessedEventLogsByIssue, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.IssueID,
			&i.Source,
			&i.EventType,
			&i.Payload,
			&i.ExternalID,
			&i.DedupeKey,
			&i.ProcessedAt,
			&i.ProcessingError,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventLogFailed = `-- name: MarkEventLogFailed :exec
UPDATE event_logs
SET processed_at = now(), processing_error = $2
WHERE id = $1
`

type MarkEventLogFailedParams struct {
	ID              int64   `json:"id"`
	ProcessingError *string `json:"processing_error"`
}

func (q *Queries) MarkEventLogFailed(ctx context.Context, arg MarkEventLogFailedParams) error {
	_, err := q.db.Exec(ctx, markEventLogFailed, arg.ID, arg.ProcessingError)
	return err
}

const markEventLogProcessed = `-- name: MarkEventLogProcessed :exec
UPDATE event_logs
SET processed_at = now()
WHERE id = $1
`

func (q *Queries) MarkEventLogProcessed(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markEventLogProcessed, id)
	return err
}

const markEventLogsBatchProcessed = `-- name: MarkEventLogsBatchProcessed :exec
UPDATE event_logs
SET processed_at = now()
WHERE id = ANY($1::bigint[])
`

// Mark multiple event logs as processed in a single query.
func (q *Queries) MarkEventLogsBatchProcessed(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, markEventLogsBatchProcessed, dollar_1)
	return err
}

const upsertEventLog = `-- name: UpsertEventLog :one
INSERT INTO event_logs (
    id, workspace_id, issue_id, source, event_type,
    payload, external_id, dedupe_key, created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now())
ON CONFLICT (workspace_id, dedupe_key)
DO UPDATE
SET
    dedupe_key = event_logs.dedupe_key
RETURNING id, workspace_id, issue_id, source, event_type, payload, external_id, dedupe_key, processed_at, processing_error, created_at
`

type UpsertEventLogParams struct {
	ID          int64   `json:"id"`
	WorkspaceID int64   `json:"workspace_id"`
	IssueID     int64   `json:"issue_id"`
	Source      string  `json:"source"`
	EventType   string  `json:"event_type"`
	Payload     []byte  `json:"payload"`
	ExternalID  *string `json:"external_id"`
	DedupeKey   string  `json:"dedupe_key"`
}

func (q *Queries) UpsertEventLog(ctx context.Context, arg UpsertEventLogParams) (EventLog, error) {
	row := q.db.QueryRow(ctx, upsertEventLog,
		arg.ID,
		arg.WorkspaceID,
		arg.IssueID,
		arg.Source,
		arg.EventType,
		arg.Payload,
		arg.ExternalID,
		arg.DedupeKey,
	)
	var i EventLog
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.IssueID,
		&i.Source,
		&i.EventType,
		&i.Payload,
		&i.ExternalID,
		&i.DedupeKey,
		&i.ProcessedAt,
		&i.ProcessingError,
		&i.CreatedAt,
	)
	return i, err
}
