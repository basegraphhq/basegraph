// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: issues.sql

package sqlc

import (
	"context"
)

const claimQueuedIssue = `-- name: ClaimQueuedIssue :one
UPDATE issues
SET processing_status = 'processing',
    processing_started_at = now(),
    updated_at = now()
WHERE id = $1
  AND processing_status = 'queued'
RETURNING id, integration_id, external_project_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

// Atomically transition issue from 'queued' to 'processing'.
// Returns the issue if claimed, no rows if already claimed by another worker.
func (q *Queries) ClaimQueuedIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, claimQueuedIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalProjectID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssue = `-- name: GetIssue :one
SELECT id, integration_id, external_project_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at FROM issues WHERE id = $1
`

func (q *Queries) GetIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalProjectID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssueByIntegrationAndExternalID = `-- name: GetIssueByIntegrationAndExternalID :one
SELECT id, integration_id, external_project_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at FROM issues WHERE integration_id = $1 AND external_issue_id = $2
`

type GetIssueByIntegrationAndExternalIDParams struct {
	IntegrationID   int64  `json:"integration_id"`
	ExternalIssueID string `json:"external_issue_id"`
}

func (q *Queries) GetIssueByIntegrationAndExternalID(ctx context.Context, arg GetIssueByIntegrationAndExternalIDParams) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssueByIntegrationAndExternalID, arg.IntegrationID, arg.ExternalIssueID)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalProjectID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const queueIssueIfIdle = `-- name: QueueIssueIfIdle :one
UPDATE issues
SET processing_status = 'queued',
    processing_started_at = NULL,
    updated_at = now()
WHERE id = $1
  AND (
    processing_status = 'idle'
    OR (processing_status = 'processing' AND processing_started_at < NOW() - INTERVAL '15 minutes')
    OR (processing_status = 'queued' AND updated_at < NOW() - INTERVAL '15 minutes')
  )
RETURNING id, integration_id, external_project_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

// Queue an issue for processing, with automatic recovery of stuck issues.
//
// This query handles three scenarios:
//
//  1. NORMAL PATH (idle → queued)
//     Issue is idle and ready to be processed. This is the happy path.
//
//  2. STUCK IN 'processing' (processing → queued after 15 min)
//     Worker crashed after claiming the issue (TX1) but before completing (TX2).
//     The issue is stuck in 'processing' forever. When user pings again after
//     15 minutes, we reset it to 'queued' so it can be reprocessed.
//
//  3. STUCK IN 'queued' (remains queued, but gets re-queued after 15 min)
//     Server crashed after QueueIfIdle but before publishing to Redis.
//     The issue is stuck in 'queued' with no Redis message. When user pings
//     again after 15 minutes, we update it (triggering a new Redis publish).
//
// Why 15 minutes?
//   - LLM calls typically take 5-60 seconds, never 15 minutes
//   - Gives legitimate processing plenty of time to complete
//   - Short enough that users don't wait too long before "ping again" works
//
// Why this approach instead of a background reclaimer?
//   - Simpler: one SQL query vs. separate goroutine with timers
//   - User-triggered: recovery happens when user cares enough to ping again
//   - Matches UX: "ping again if no response" - just like a human teammate
func (q *Queries) QueueIssueIfIdle(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, queueIssueIfIdle, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalProjectID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setIssueIdle = `-- name: SetIssueIdle :execrows
UPDATE issues
SET processing_status = 'idle',
    last_processed_at = now(),
    processing_started_at = NULL,
    updated_at = now()
WHERE id = $1
  AND processing_status = 'processing'
`

// Transition issue from 'processing' to 'idle'.
func (q *Queries) SetIssueIdle(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, setIssueIdle, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertIssue = `-- name: UpsertIssue :one
INSERT INTO issues (
    id,
    integration_id,
    external_project_id,
    external_issue_id,
    provider,
    title,
    description,
    labels,
    members,
    assignees,
    reporter,
    keywords,
    code_findings,
    learnings,
    discussions,
    spec,
    created_at,
    updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, now(), now()
)
ON CONFLICT (integration_id, external_issue_id)
DO UPDATE
SET
    external_project_id = EXCLUDED.external_project_id,
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    labels = EXCLUDED.labels,
    members = EXCLUDED.members,
    assignees = EXCLUDED.assignees,
    reporter = EXCLUDED.reporter,
    keywords = EXCLUDED.keywords,
    code_findings = EXCLUDED.code_findings,
    learnings = EXCLUDED.learnings,
    discussions = EXCLUDED.discussions,
    spec = EXCLUDED.spec,
    updated_at = now()
RETURNING id, integration_id, external_project_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

type UpsertIssueParams struct {
	ID                int64    `json:"id"`
	IntegrationID     int64    `json:"integration_id"`
	ExternalProjectID *string  `json:"external_project_id"`
	ExternalIssueID   string   `json:"external_issue_id"`
	Provider          string   `json:"provider"`
	Title             *string  `json:"title"`
	Description       *string  `json:"description"`
	Labels            []string `json:"labels"`
	Members           []string `json:"members"`
	Assignees         []string `json:"assignees"`
	Reporter          *string  `json:"reporter"`
	Keywords          []byte   `json:"keywords"`
	CodeFindings      []byte   `json:"code_findings"`
	Learnings         []byte   `json:"learnings"`
	Discussions       []byte   `json:"discussions"`
	Spec              *string  `json:"spec"`
}

func (q *Queries) UpsertIssue(ctx context.Context, arg UpsertIssueParams) (Issue, error) {
	row := q.db.QueryRow(ctx, upsertIssue,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalProjectID,
		arg.ExternalIssueID,
		arg.Provider,
		arg.Title,
		arg.Description,
		arg.Labels,
		arg.Members,
		arg.Assignees,
		arg.Reporter,
		arg.Keywords,
		arg.CodeFindings,
		arg.Learnings,
		arg.Discussions,
		arg.Spec,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalProjectID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
