// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: issues.sql

package sqlc

import (
	"context"
)

const getIssue = `-- name: GetIssue :one
SELECT id, integration_id, external_issue_id, title, description, labels, members, assignees, reporter, keywords, code_findings, learnings, discussions, spec, created_at, updated_at FROM issues WHERE id = $1
`

func (q *Queries) GetIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssueByIntegrationAndExternalID = `-- name: GetIssueByIntegrationAndExternalID :one
SELECT id, integration_id, external_issue_id, title, description, labels, members, assignees, reporter, keywords, code_findings, learnings, discussions, spec, created_at, updated_at FROM issues WHERE integration_id = $1 AND external_issue_id = $2
`

type GetIssueByIntegrationAndExternalIDParams struct {
	IntegrationID   int64  `json:"integration_id"`
	ExternalIssueID string `json:"external_issue_id"`
}

func (q *Queries) GetIssueByIntegrationAndExternalID(ctx context.Context, arg GetIssueByIntegrationAndExternalIDParams) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssueByIntegrationAndExternalID, arg.IntegrationID, arg.ExternalIssueID)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertIssue = `-- name: UpsertIssue :one
INSERT INTO issues (
    id,
    integration_id,
    external_issue_id,
    title,
    description,
    labels,
    members,
    assignees,
    reporter,
    keywords,
    code_findings,
    learnings,
    discussions,
    spec,
    created_at,
    updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, now(), now()
)
ON CONFLICT (integration_id, external_issue_id)
DO UPDATE
SET
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    labels = EXCLUDED.labels,
    members = EXCLUDED.members,
    assignees = EXCLUDED.assignees,
    reporter = EXCLUDED.reporter,
    keywords = EXCLUDED.keywords,
    code_findings = EXCLUDED.code_findings,
    learnings = EXCLUDED.learnings,
    discussions = EXCLUDED.discussions,
    spec = EXCLUDED.spec,
    updated_at = now()
RETURNING id, integration_id, external_issue_id, title, description, labels, members, assignees, reporter, keywords, code_findings, learnings, discussions, spec, created_at, updated_at
`

type UpsertIssueParams struct {
	ID              int64    `json:"id"`
	IntegrationID   int64    `json:"integration_id"`
	ExternalIssueID string   `json:"external_issue_id"`
	Title           *string  `json:"title"`
	Description     *string  `json:"description"`
	Labels          []string `json:"labels"`
	Members         []string `json:"members"`
	Assignees       []string `json:"assignees"`
	Reporter        *string  `json:"reporter"`
	Keywords        []string `json:"keywords"`
	CodeFindings    []byte   `json:"code_findings"`
	Learnings       []byte   `json:"learnings"`
	Discussions     []byte   `json:"discussions"`
	Spec            *string  `json:"spec"`
}

func (q *Queries) UpsertIssue(ctx context.Context, arg UpsertIssueParams) (Issue, error) {
	row := q.db.QueryRow(ctx, upsertIssue,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalIssueID,
		arg.Title,
		arg.Description,
		arg.Labels,
		arg.Members,
		arg.Assignees,
		arg.Reporter,
		arg.Keywords,
		arg.CodeFindings,
		arg.Learnings,
		arg.Discussions,
		arg.Spec,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
