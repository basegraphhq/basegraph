// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: issues.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimQueuedIssue = `-- name: ClaimQueuedIssue :one
UPDATE issues
SET processing_status = 'processing',
    processing_started_at = now(),
    updated_at = now()
WHERE id = $1
  AND processing_status = 'queued'
RETURNING id, integration_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

// Atomically transition issue from 'queued' to 'processing'.
// Returns the issue if claimed, no rows if already claimed by another worker.
func (q *Queries) ClaimQueuedIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, claimQueuedIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findStuckIssues = `-- name: FindStuckIssues :many
SELECT id FROM issues
WHERE processing_status = 'processing'
  AND processing_started_at IS NOT NULL
  AND processing_started_at < $1
ORDER BY processing_started_at ASC
LIMIT $2
`

type FindStuckIssuesParams struct {
	ProcessingStartedAt pgtype.Timestamptz `json:"processing_started_at"`
	Limit               int32              `json:"limit"`
}

// Find issues stuck in 'processing' state longer than the specified duration.
// Used by the PostgreSQL reclaimer to identify issues where the worker crashed.
func (q *Queries) FindStuckIssues(ctx context.Context, arg FindStuckIssuesParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, findStuckIssues, arg.ProcessingStartedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findStuckQueuedIssues = `-- name: FindStuckQueuedIssues :many
SELECT id FROM issues
WHERE processing_status = 'queued'
  AND updated_at < $1
ORDER BY updated_at ASC
LIMIT $2
`

type FindStuckQueuedIssuesParams struct {
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Limit     int32              `json:"limit"`
}

// Find issues stuck in 'queued' state longer than the specified duration.
// This handles server crash after QueueIfIdle but before Redis XADD.
func (q *Queries) FindStuckQueuedIssues(ctx context.Context, arg FindStuckQueuedIssuesParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, findStuckQueuedIssues, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssue = `-- name: GetIssue :one
SELECT id, integration_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at FROM issues WHERE id = $1
`

func (q *Queries) GetIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIssueByIntegrationAndExternalID = `-- name: GetIssueByIntegrationAndExternalID :one
SELECT id, integration_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at FROM issues WHERE integration_id = $1 AND external_issue_id = $2
`

type GetIssueByIntegrationAndExternalIDParams struct {
	IntegrationID   int64  `json:"integration_id"`
	ExternalIssueID string `json:"external_issue_id"`
}

func (q *Queries) GetIssueByIntegrationAndExternalID(ctx context.Context, arg GetIssueByIntegrationAndExternalIDParams) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssueByIntegrationAndExternalID, arg.IntegrationID, arg.ExternalIssueID)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const queueIssueIfIdle = `-- name: QueueIssueIfIdle :one
UPDATE issues
SET processing_status = 'queued',
    updated_at = now()
WHERE id = $1
  AND processing_status = 'idle'
RETURNING id, integration_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

// Atomically transition issue from 'idle' to 'queued'.
// Returns the issue if transition happened, no rows if already queued/processing.
func (q *Queries) QueueIssueIfIdle(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, queueIssueIfIdle, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const reclaimStuckIssue = `-- name: ReclaimStuckIssue :one
UPDATE issues
SET processing_status = 'queued',
    processing_started_at = NULL,
    updated_at = now()
WHERE id = $1
  AND processing_status = 'processing'
RETURNING id
`

// Reset a stuck issue from 'processing' back to 'queued'.
// Returns the issue ID if reset succeeded, no rows if already reclaimed.
func (q *Queries) ReclaimStuckIssue(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, reclaimStuckIssue, id)
	err := row.Scan(&id)
	return id, err
}

const resetQueuedToIdle = `-- name: ResetQueuedToIdle :execrows
UPDATE issues
SET processing_status = 'idle',
    updated_at = now()
WHERE id = $1
  AND processing_status = 'queued'
`

// Reset a 'queued' issue back to 'idle' when there are no events to process.
// Used by PG reclaimer for stuck 'queued' issues that have no pending events.
func (q *Queries) ResetQueuedToIdle(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, resetQueuedToIdle, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setIssueProcessed = `-- name: SetIssueProcessed :execrows
UPDATE issues
SET processing_status = 'idle',
    last_processed_at = now(),
    processing_started_at = NULL,
    updated_at = now()
WHERE id = $1
  AND processing_status = 'processing'
`

// Mark issue processing complete. Transition from 'processing' to 'idle'.
func (q *Queries) SetIssueProcessed(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, setIssueProcessed, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertIssue = `-- name: UpsertIssue :one
INSERT INTO issues (
    id,
    integration_id,
    external_issue_id,
    provider,
    title,
    description,
    labels,
    members,
    assignees,
    reporter,
    keywords,
    code_findings,
    learnings,
    discussions,
    spec,
    created_at,
    updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, now(), now()
)
ON CONFLICT (integration_id, external_issue_id)
DO UPDATE
SET
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    labels = EXCLUDED.labels,
    members = EXCLUDED.members,
    assignees = EXCLUDED.assignees,
    reporter = EXCLUDED.reporter,
    keywords = EXCLUDED.keywords,
    code_findings = EXCLUDED.code_findings,
    learnings = EXCLUDED.learnings,
    discussions = EXCLUDED.discussions,
    spec = EXCLUDED.spec,
    updated_at = now()
RETURNING id, integration_id, external_issue_id, provider, title, description, labels, members, assignees, reporter, external_issue_url, keywords, code_findings, learnings, discussions, spec, processing_status, processing_started_at, last_processed_at, created_at, updated_at
`

type UpsertIssueParams struct {
	ID              int64    `json:"id"`
	IntegrationID   int64    `json:"integration_id"`
	ExternalIssueID string   `json:"external_issue_id"`
	Provider        string   `json:"provider"`
	Title           *string  `json:"title"`
	Description     *string  `json:"description"`
	Labels          []string `json:"labels"`
	Members         []string `json:"members"`
	Assignees       []string `json:"assignees"`
	Reporter        *string  `json:"reporter"`
	Keywords        []byte   `json:"keywords"`
	CodeFindings    []byte   `json:"code_findings"`
	Learnings       []byte   `json:"learnings"`
	Discussions     []byte   `json:"discussions"`
	Spec            *string  `json:"spec"`
}

func (q *Queries) UpsertIssue(ctx context.Context, arg UpsertIssueParams) (Issue, error) {
	row := q.db.QueryRow(ctx, upsertIssue,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalIssueID,
		arg.Provider,
		arg.Title,
		arg.Description,
		arg.Labels,
		arg.Members,
		arg.Assignees,
		arg.Reporter,
		arg.Keywords,
		arg.CodeFindings,
		arg.Learnings,
		arg.Discussions,
		arg.Spec,
	)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalIssueID,
		&i.Provider,
		&i.Title,
		&i.Description,
		&i.Labels,
		&i.Members,
		&i.Assignees,
		&i.Reporter,
		&i.ExternalIssueUrl,
		&i.Keywords,
		&i.CodeFindings,
		&i.Learnings,
		&i.Discussions,
		&i.Spec,
		&i.ProcessingStatus,
		&i.ProcessingStartedAt,
		&i.LastProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
