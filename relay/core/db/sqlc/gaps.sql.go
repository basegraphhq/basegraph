// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: gaps.sql

package sqlc

import (
	"context"
)

const closeGap = `-- name: CloseGap :one
UPDATE gaps
SET status = $2, -- 'resolved' | 'skipped'
    closed_reason = $3, -- answered | inferred | not_relevant
    closed_note = $4,
    resolved_at = now()
WHERE id = $1
RETURNING id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at
`

type CloseGapParams struct {
	ID           int64   `json:"id"`
	Status       string  `json:"status"`
	ClosedReason *string `json:"closed_reason"`
	ClosedNote   *string `json:"closed_note"`
}

func (q *Queries) CloseGap(ctx context.Context, arg CloseGapParams) (Gap, error) {
	row := q.db.QueryRow(ctx, closeGap,
		arg.ID,
		arg.Status,
		arg.ClosedReason,
		arg.ClosedNote,
	)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const countOpenBlockingGapsByIssue = `-- name: CountOpenBlockingGapsByIssue :one
SELECT COUNT(*)::bigint FROM gaps
WHERE issue_id = $1 AND status = 'open' AND severity = 'blocking'
`

func (q *Queries) CountOpenBlockingGapsByIssue(ctx context.Context, issueID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countOpenBlockingGapsByIssue, issueID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createGap = `-- name: CreateGap :one
INSERT INTO gaps (
    id,
    issue_id,
    status,
    question,
    evidence,
    severity,
    respondent
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at
`

type CreateGapParams struct {
	ID         int64   `json:"id"`
	IssueID    int64   `json:"issue_id"`
	Status     string  `json:"status"`
	Question   string  `json:"question"`
	Evidence   *string `json:"evidence"`
	Severity   string  `json:"severity"`
	Respondent string  `json:"respondent"`
}

func (q *Queries) CreateGap(ctx context.Context, arg CreateGapParams) (Gap, error) {
	row := q.db.QueryRow(ctx, createGap,
		arg.ID,
		arg.IssueID,
		arg.Status,
		arg.Question,
		arg.Evidence,
		arg.Severity,
		arg.Respondent,
	)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getGap = `-- name: GetGap :one
SELECT id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at FROM gaps WHERE id = $1
`

func (q *Queries) GetGap(ctx context.Context, id int64) (Gap, error) {
	row := q.db.QueryRow(ctx, getGap, id)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getGapByShortID = `-- name: GetGapByShortID :one
SELECT id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at FROM gaps WHERE short_id = $1
`

func (q *Queries) GetGapByShortID(ctx context.Context, shortID int64) (Gap, error) {
	row := q.db.QueryRow(ctx, getGapByShortID, shortID)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const listClosedGapsByIssue = `-- name: ListClosedGapsByIssue :many
SELECT id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at FROM gaps
WHERE issue_id = $1 AND status != 'open'
ORDER BY COALESCE(resolved_at, created_at) DESC
LIMIT $2
`

type ListClosedGapsByIssueParams struct {
	IssueID int64 `json:"issue_id"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) ListClosedGapsByIssue(ctx context.Context, arg ListClosedGapsByIssueParams) ([]Gap, error) {
	rows, err := q.db.Query(ctx, listClosedGapsByIssue, arg.IssueID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gap
	for rows.Next() {
		var i Gap
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.IssueID,
			&i.Status,
			&i.ClosedReason,
			&i.ClosedNote,
			&i.Question,
			&i.Evidence,
			&i.Severity,
			&i.Respondent,
			&i.LearningID,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGapsByIssue = `-- name: ListGapsByIssue :many
SELECT id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at FROM gaps
WHERE issue_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListGapsByIssue(ctx context.Context, issueID int64) ([]Gap, error) {
	rows, err := q.db.Query(ctx, listGapsByIssue, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gap
	for rows.Next() {
		var i Gap
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.IssueID,
			&i.Status,
			&i.ClosedReason,
			&i.ClosedNote,
			&i.Question,
			&i.Evidence,
			&i.Severity,
			&i.Respondent,
			&i.LearningID,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenGapsByIssue = `-- name: ListOpenGapsByIssue :many
SELECT id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at FROM gaps
WHERE issue_id = $1 AND status = 'open'
ORDER BY
    CASE severity
        WHEN 'blocking' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END,
    created_at ASC
`

func (q *Queries) ListOpenGapsByIssue(ctx context.Context, issueID int64) ([]Gap, error) {
	rows, err := q.db.Query(ctx, listOpenGapsByIssue, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gap
	for rows.Next() {
		var i Gap
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.IssueID,
			&i.Status,
			&i.ClosedReason,
			&i.ClosedNote,
			&i.Question,
			&i.Evidence,
			&i.Severity,
			&i.Respondent,
			&i.LearningID,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveGap = `-- name: ResolveGap :one
UPDATE gaps
SET status = 'resolved',
    resolved_at = now()
WHERE id = $1
RETURNING id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at
`

func (q *Queries) ResolveGap(ctx context.Context, id int64) (Gap, error) {
	row := q.db.QueryRow(ctx, resolveGap, id)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const setGapLearning = `-- name: SetGapLearning :one
UPDATE gaps
SET learning_id = $2
WHERE id = $1
RETURNING id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at
`

type SetGapLearningParams struct {
	ID         int64  `json:"id"`
	LearningID *int64 `json:"learning_id"`
}

func (q *Queries) SetGapLearning(ctx context.Context, arg SetGapLearningParams) (Gap, error) {
	row := q.db.QueryRow(ctx, setGapLearning, arg.ID, arg.LearningID)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const skipGap = `-- name: SkipGap :one
UPDATE gaps
SET status = 'skipped',
    closed_reason = 'not_relevant',
    closed_note = null,
    resolved_at = now()
WHERE id = $1
RETURNING id, short_id, issue_id, status, closed_reason, closed_note, question, evidence, severity, respondent, learning_id, created_at, resolved_at
`

func (q *Queries) SkipGap(ctx context.Context, id int64) (Gap, error) {
	row := q.db.QueryRow(ctx, skipGap, id)
	var i Gap
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.IssueID,
		&i.Status,
		&i.ClosedReason,
		&i.ClosedNote,
		&i.Question,
		&i.Evidence,
		&i.Severity,
		&i.Respondent,
		&i.LearningID,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}
